#include "stdafx.h"
#include "Matrix.h"
#include <fstream>
#include <cmath>

using namespace std;

//copy constructor def
matrix::matrix(const matrix &other)
{
	nRows = other.nRows;
	nCols = other.nCols;
	m = new dvector*[nRows];
	for (int i = 0; i < nRows; i++)
	{
		m[i] = new dvector(nCols);
		*m[i] = *other.m[i];          //should i add a pointer or not?
	}

}
//assignment constructor operator
matrix &matrix::operator=(const matrix& other)
{
	if (this == &other)
	{
		return *this;
	}
	nRows = other.nRows;
	nCols = other.nCols;
	delete[] m;
	m = new dvector*[nRows];
	for (int i = 0; i < nRows; i++)
	{
		m[i] = new dvector(nCols);
	}
	return *this;
}

//user input matrix
matrix::matrix(istream & stream)
{
	stream >> nRows >> nCols;
	m = new dvector*[nRows];
	for (int i = 0; i < nRows; i++)
	{
		m[i] = new dvector(nCols);
		for (int j = 0; j < nCols; j++)
		{
			stream >> (*(m[i]))[j];
		}
	}
}

matrix::~matrix()
{
	for (int i = 0; i < nRows; i++)
	{
		delete m[i];
	}
	delete []m;
}

matrix matrix::identity()											//CREATE IDENTITY MATRIX CORRESPONDING TO MATRICES DIMENSIONS
{																	//this ones probably not too useful
	if (nRows != nCols)
	{
		cout << "*C1: choose matrix of square dimensions" << endl;
		exit(0);
	}
	matrix I(nRows, nCols);
	
	for (int i = 0; i < nRows; i++)
	{
		for (int j = 0; j < nCols; j++)
		{
			if (i == j)
			{
				(*(I.m[i]))[j] = 1;
			}
			else
			{
				(*(I.m[i]))[j] = 0;
			}
		}
	}
	return I;
}

matrix matrix::identity(int R)											//CREATE IDENTITY MATRIX CORRESPONDING TO certain dimension
{
	matrix I(R,R);

	for (int i = 0; i < R; i++)
	{
		for (int j = 0; j < R; j++)
		{
			if (i == j)
			{
				(*(I.m[i]))[j] = 1;
			}
			else
			{
				(*(I.m[i]))[j] = 0;
			}
		}
	}
	return I;
}

matrix matrix::REFmatrix(int rows, int cols)											//create a matrix that adjoins original matrix with identity
{
	rows = nRows;
	cols = nCols;
	if (nRows != nCols)
	{
		cout << "(*ERROR in RREFMATRIX fxn*Invalid.  Matrix must have same # of rows as columns" << endl;
		exit(0);
	}
	matrix I = identity(nRows);
	matrix startRREF(nRows, nRows * 2);
	for (int i = 0; i < startRREF.nRows; ++i)
	{
		for (int j = 0; j < startRREF.nCols; ++j)
		{
			if (j < nRows)
			{
				(*(startRREF.m[i]))[j] = (*m[i])[j];				//sketchy part, am i referencing actual value or address?
			}
			else
			{
				(*(startRREF.m[i]))[j] = (*(I.m[i]))[j-nRows];
			}
		}
	}
	return startRREF;
}

bool matrix::checkRowCoeff(int R)									//smaller checkRowcoeff function, bigger 1 might be useful, right under
{
	rowPosition = R;
	if (rowPosition >= nRows)
	{
		return true;
	}
	pivotPosition = rowPosition;
	for (int i = rowPosition+1; i < nRows; i++)
	{
		if ((  (*m[i])[pivotPosition] == 0 && (*m[rowPosition])[pivotPosition] == 1))
		{
			pivotPosition = pivotPosition + 1;
			return true;
		}
	}
	return false;
}
void matrix::rowXreciprocal(int R)
{
	double leadingCoeff = (*m[R])[pivotPosition];

	if (leadingCoeff == 0)											//this part swaps rows if top row has nonzero leading coefficient
	{
		for (int i = R + 1; i < nRows; i++)							//turn this into its own function later!!
		{
			if ((*m[i])[pivotPosition] != 0)
			{
				swapRows(nCols, R, i);
				leadingCoeff = (*m[R])[pivotPosition];
			}
			break;
		}
	}
	for (int j = pivotPosition; j < nCols; j++)
	{
		(*m[R])[j] = (*m[R])[j] * (1 / leadingCoeff);
		(*m[R])[j] = sqrt(pow((*m[R])[j], 2));   
	}
	
}
void matrix::reduceLowerDiag(int R)
{
	pivotPosition = R;
	for (int i = (R + 1); i < nRows; ++i)
	{
		double leadingCoeff = (*m[i])[pivotPosition];
		
		for (int j = pivotPosition; j < nCols; ++j)
		{
			(*m[i])[j] = (*m[i])[j] + ((-1)*leadingCoeff * (*m[R])[j]);    //CHECK, this is complex.  
		}
	}
}
void matrix::reduceUpperDiag(int R)					//after getting diagonal of 1's, call this function to reduce top entries starting with Row indice R
{
	rowPosition = R;
	pivotPosition = rowPosition + 1;
	int count = 0;


	
	while (pivotPosition < nRows)
	{
		double leadingCoeff = (*m[rowPosition])[pivotPosition];
		for (int i = pivotPosition; i < nCols; ++i)
		{
			(*m[rowPosition])[i] = (*m[rowPosition])[i] + (-1 * leadingCoeff)*((*m[pivotPosition])[i]);
		}
		pivotPosition = pivotPosition + 1;
	}
	
	
}


/*bool matrix::checkRowCoeff(int R)
{
	rowPosition = R;
	
	for (int i = rowPosition; i < nRows; ++i)							//iterates thru rows, starting with the next row that
	{																	//that needs its leading coefficient to turn to 1	
		if ((*m[i])[pivotPosition] != 0)
		{		
			if (i != rowPosition) { swapRows(nCols, rowPosition, i); }	//in case row had a leading coefficient of 0, hte first row with
																		//nonzero leading coeffficient is swapped with the first row
			double leadingCoeff = (*m[rowPosition])[pivotPosition];				
			for (int j = pivotPosition; j < nCols; ++j)					//then each member of that row is multiplied by the reciprocal
			{															//of the leading coeffficient
				(*m[rowPosition])[j] = ((*m[rowPosition])[j]) * (1 / leadingCoeff);			//<-----(HERE) ^^
				(*m[rowPosition])[j] = sqrt(pow((*m[rowPosition])[j], 2));				//ensure it is positive
			}
				
		}																
		break;													//Since we now have reduced the most recent row, we break out of loop for next step
	}
		
	for (int i = rowPosition + 1; i < nRows; ++i)
	{
		if ((*m[i])[pivotPosition] != 0)					//Program goes through all rows after the last one to be reduced
		{
			double factor;									
			factor = (-1) * ((*m[i])[pivotPosition]);		//The factor is hte number that you multiply the recently-reduced row	
			for (int j = pivotPosition; j < nCols; ++j)		//with to add each entry to the new row
			{
				(*m[i])[j] = (*m[i])[j] + ((*m[rowPosition])[j] * factor);		//after this, all entries in the pivotposition column 
			}																	//below the 1 should be 0		
		}
	}
	for (int i = rowPosition + 1; i < nRows; ++i)					
	{
		while ((*m[i])[0] != 0)							//itertes through all rows again, if any entries in 
		{															//pivotpositionTH column aren't 0, it returns false
			return false;
		}

		rowPosition = rowPosition + 1; 
		pivotPosition = pivotPosition + 1;							//if they're all 0, the matrix object's associated rowposition
		return true;												//and pivotposition are increased so when checkRow is called again
	}																//it starts at the next part of hte matrix


}*/            



void matrix::swapRows(int Cols, int X1, int X2)					//cols is vector size, X1 and X2 are row indices to be swapped
{
	dvector temp(Cols);
	temp = *m[X1];
	*m[X1] = *m[X2];
	*m[X2] = temp;
}


//transpose matrix
matrix *transpose(matrix &other)
{
	matrix *a = new matrix(other.nCols, other.nRows);

	for (int i = 0; i < a->nRows; i++)
	{
		for (int j = 0; j < a->nCols; j++)
		{
			(*(a->m[i]))[j] = (*(other.m[j]))[i];
			
		}
	}
	return a;
}

void matrix::inverse()				
{
	matrix New = REFmatrix(nRows, nCols);
	
	int row = 0;
	while (!New.checkRowCoeff(row))
	{
		New.rowXreciprocal(row);
		New.reduceLowerDiag(row);
		row = row + 1;
	}
	row = 0;
	
	while (row < nRows)
	{
		New.reduceUpperDiag(row);
		row = row + 1;
	}

	for (int i = 0; i < New.nRows; i++)
	{
		
		for (int j = 0; j < New.nRows; j++)
		{
			(*(m[i]))[j] = ((*New.m[i]))[j + New.nRows];
		}
	}
}
matrix &matrix::operator+(const matrix& other)
{
	if (other.nCols != nCols || other.nRows != nRows)
	{
		cout << "invalid. matrixes must be the same size to add" << endl;
		exit(0);
	}
	for (int i = 0; i < nRows; i++)
	{
		*m[i] = *m[i] + *other.m[i];
	}
	return *this;
}
void matrix::output()
{
	if (checkInverse == 0)
		cout << "Here is your matrix: " << endl;
	else
		cout << "Here is the inverted matrix: " << endl;
	for (int i = 0; i < nRows; i++)
	{
		cout << *m[i] << endl;
	}
}
void matrix::appendVector(const dvector& other) //???syntax, const, reference??
{
	*m[emptyRow] = other;
	emptyRow = emptyRow + 1;
}
double matrix::det()				//calculate just 2x2 determinants for now!!
{
	double D;
	if (nCols = 2 && nCols == nRows)
	{
		D = ((*m[0])[0] * (*m[1])[1]) - ((*m[0])[1] * (*m[1])[0]);
	}
	determinant = D;
	return D;
	
}
bool matrix::isSquare()									//function to see if matrix is square, not working for some reason!!
{
	if (nRows != nCols)
	{
		return false;
	}
	return true;
}









//DVECTOR FUNCTION DEFINITIONS
dvector::dvector(const dvector& other) {
	
	size = other.size;
	v = new double[other.size];
	for (int i = 0; i < other.size; i++)
	{
		v[i] = other.v[i];
	}
}

dvector &dvector::operator=(const dvector& other) {
	
	if (this == &other)
	{
		return *this;
	}

	size = other.size;
	delete[] v;
	v = new double[size];
	for (int i = 0; i < size; i++)
	{
		v[i] = other.v[i];
	}

	return *this;
}
//
void dvector::make()
{
	cout << " enter the entries of your vector one by one" << endl;
	for (int i = 0; i < size; i++)
	{
		int entry;
		cin >> entry;
		v[i] = entry;
	}

}
//
dvector &dvector::operator+(const dvector& other) {

	for (int i = 0; i < other.size; i++)
	{
		v[i] = v[i] + other.v[i];
	}
	return *this;
}
double &dvector::operator[](int i) {
	if (i >= size)
	{
		cout << "invalid index" << endl;
		exit(0);
	}
	return *(v + i);
}
dvector &dvector::operator*(const dvector& other) {

	if (size != other.size)
	{
		cout << "size of the two vectors is not the same, cannot multiplicate" << endl;
		exit(0);
	}
	for (int i = 0; i < size; i++)
	{
		v[i] = v[i] * other.v[i];
	}
	return *this;
}



void dvector::output() 
{
 
	for (int i = 0; i < size; i++)
	{
		cout << v[i] << " ";
	}
	cout << endl;
}





int main()
{


	matrix A(cin);
	A.output();

	A.inverse();
	cout << "got past invers function" << endl;
	A.output();


	
	
		
	
	
	return 0;
}


